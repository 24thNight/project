{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nimport { useClarificationStore } from '../store/clarificationStore';\nimport { clarificationApi } from '../utils/api';\nimport { toast } from 'sonner';\nimport { t } from '../../../lib/i18n';\nexport const useClarificationSession = (planId, lang = 'en') => {\n  _s();\n  const {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    initSession,\n    resetSession,\n    handleStreamEvent,\n    setError,\n    setLoading,\n    addAnswer,\n    completeSession\n  } = useClarificationStore();\n  const streamRef = useRef(null);\n\n  // Start a new session\n  const startSession = useCallback(async () => {\n    try {\n      setLoading(true);\n      resetSession();\n\n      // Start a session via the API\n      const sessionId = await clarificationApi.startSession(planId, lang);\n\n      // Initialize local session state\n      initSession(planId);\n\n      // Create SSE connection for question streaming\n      if (sessionId) {\n        streamRef.current = clarificationApi.createQuestionStream(sessionId, event => handleStreamEvent(event), errorMsg => setError(errorMsg), lang);\n      }\n    } catch (err) {\n      setError(t('clarify.error.startFailed', lang));\n      toast.error(t('clarify.error.startFailed', lang));\n    } finally {\n      setLoading(false);\n    }\n  }, [planId, lang, initSession, resetSession, setLoading, setError, handleStreamEvent]);\n\n  // Submit an answer to the current question\n  const submitAnswer = useCallback(async value => {\n    if (!session || !session.questions.length) {\n      return false;\n    }\n    try {\n      const currentQuestion = session.questions[session.currentQuestionIndex];\n      if (!currentQuestion) {\n        return false;\n      }\n      const answer = {\n        questionId: currentQuestion.id,\n        value,\n        timestamp: new Date()\n      };\n\n      // Add the answer to the local state\n      addAnswer(answer);\n\n      // Submit the answer to the backend\n      if (session.id) {\n        await clarificationApi.submitAnswer(session.id, answer, lang);\n      }\n      return true;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Error submitting answer:', err);\n      }\n      toast.error(t('api.errors.update', lang));\n      return false;\n    }\n  }, [session, addAnswer, lang]);\n\n  // Finish the session and generate the plan\n  const finishSession = useCallback(async () => {\n    if (!session || session.status !== 'in_progress') {\n      return null;\n    }\n    try {\n      setLoading(true);\n\n      // Mark the session as complete locally\n      completeSession();\n\n      // Complete the session on the backend and generate the plan\n      if (session.id) {\n        const generatedPlanId = await clarificationApi.completeSession(session.id, lang);\n        return generatedPlanId;\n      }\n      return null;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Error completing session:', err);\n      }\n      toast.error(t('api.errors.default', lang));\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [session, completeSession, setLoading, lang]);\n\n  // Cleanup effect\n  useEffect(() => {\n    return () => {\n      // Close the SSE connection when the component unmounts\n      if (streamRef.current) {\n        streamRef.current.close();\n        streamRef.current = null;\n      }\n    };\n  }, []);\n  return {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    startSession,\n    submitAnswer,\n    finishSession,\n    resetSession\n  };\n};\n_s(useClarificationSession, \"lW86liPKj7sDnLbm4iRcsQJ2Dtc=\", false, function () {\n  return [useClarificationStore];\n});","map":{"version":3,"names":["useEffect","useRef","useCallback","useClarificationStore","clarificationApi","toast","t","useClarificationSession","planId","lang","_s","session","isLoading","error","isStreamingQuestion","currentStreamedText","initSession","resetSession","handleStreamEvent","setError","setLoading","addAnswer","completeSession","streamRef","startSession","sessionId","current","createQuestionStream","event","errorMsg","err","submitAnswer","value","questions","length","currentQuestion","currentQuestionIndex","answer","questionId","id","timestamp","Date","process","env","NODE_ENV","console","finishSession","status","generatedPlanId","close"],"sources":["/home/devbox/project/src/features/clarification/hooks/useClarificationSession.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\nimport { useClarificationStore } from '../store/clarificationStore';\nimport { clarificationApi } from '../utils/api';\nimport { Answer, StreamEvent } from '../types';\nimport { toast } from 'sonner';\nimport { t } from '../../../lib/i18n';\nimport { Language } from '../../../lib/i18n';\n\nexport const useClarificationSession = (planId?: string, lang: Language = 'en') => {\n  const {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    initSession,\n    resetSession,\n    handleStreamEvent,\n    setError,\n    setLoading,\n    addAnswer,\n    completeSession,\n  } = useClarificationStore();\n  \n  const streamRef = useRef<{ close: () => void } | null>(null);\n  \n  // Start a new session\n  const startSession = useCallback(async () => {\n    try {\n      setLoading(true);\n      resetSession();\n      \n      // Start a session via the API\n      const sessionId = await clarificationApi.startSession(planId, lang);\n      \n      // Initialize local session state\n      initSession(planId);\n      \n      // Create SSE connection for question streaming\n      if (sessionId) {\n        streamRef.current = clarificationApi.createQuestionStream(\n          sessionId,\n          (event: StreamEvent) => handleStreamEvent(event),\n          (errorMsg: string) => setError(errorMsg),\n          lang\n        );\n      }\n    } catch (err) {\n      setError(t('clarify.error.startFailed', lang));\n      toast.error(t('clarify.error.startFailed', lang));\n    } finally {\n      setLoading(false);\n    }\n  }, [planId, lang, initSession, resetSession, setLoading, setError, handleStreamEvent]);\n  \n  // Submit an answer to the current question\n  const submitAnswer = useCallback(async (value: string | number) => {\n    if (!session || !session.questions.length) {\n      return false;\n    }\n    \n    try {\n      const currentQuestion = session.questions[session.currentQuestionIndex];\n      \n      if (!currentQuestion) {\n        return false;\n      }\n      \n      const answer: Answer = {\n        questionId: currentQuestion.id,\n        value,\n        timestamp: new Date(),\n      };\n      \n      // Add the answer to the local state\n      addAnswer(answer);\n      \n      // Submit the answer to the backend\n      if (session.id) {\n        await clarificationApi.submitAnswer(session.id, answer, lang);\n      }\n      \n      return true;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Error submitting answer:', err);\n      }\n      toast.error(t('api.errors.update', lang));\n      return false;\n    }\n  }, [session, addAnswer, lang]);\n  \n  // Finish the session and generate the plan\n  const finishSession = useCallback(async () => {\n    if (!session || session.status !== 'in_progress') {\n      return null;\n    }\n    \n    try {\n      setLoading(true);\n      \n      // Mark the session as complete locally\n      completeSession();\n      \n      // Complete the session on the backend and generate the plan\n      if (session.id) {\n        const generatedPlanId = await clarificationApi.completeSession(session.id, lang);\n        return generatedPlanId;\n      }\n      \n      return null;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Error completing session:', err);\n      }\n      toast.error(t('api.errors.default', lang));\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [session, completeSession, setLoading, lang]);\n  \n  // Cleanup effect\n  useEffect(() => {\n    return () => {\n      // Close the SSE connection when the component unmounts\n      if (streamRef.current) {\n        streamRef.current.close();\n        streamRef.current = null;\n      }\n    };\n  }, []);\n  \n  return {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    startSession,\n    submitAnswer,\n    finishSession,\n    resetSession,\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}