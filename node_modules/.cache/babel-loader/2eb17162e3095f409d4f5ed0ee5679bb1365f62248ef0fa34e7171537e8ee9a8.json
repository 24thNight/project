{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nimport { useClarificationStore } from '../store/clarificationStore';\nimport { clarificationApi } from '../utils/api';\nimport { toast } from 'sonner';\nimport { t } from '../../../lib/i18n';\n// 开发环境的日志帮助函数\nconst devLog = (message, ...args) => {\n  if (process.env.NODE_ENV !== 'production') {\n    console.log(`[Clarification Session] ${message}`, ...args);\n  }\n};\nexport const useClarificationSession = (planId, lang = 'en') => {\n  _s();\n  const {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    initSession,\n    resetSession,\n    handleStreamEvent,\n    setError,\n    setLoading,\n    addAnswer,\n    completeSession\n  } = useClarificationStore();\n  const streamRef = useRef(null);\n\n  // Start a new session\n  const startSession = useCallback(async () => {\n    devLog('Starting new session');\n    try {\n      setLoading(true);\n      resetSession();\n\n      // Start a session via the API\n      devLog('Calling API to start session');\n      const sessionId = await clarificationApi.startSession(planId, lang);\n      devLog('Session started with ID:', sessionId);\n\n      // Initialize local session state\n      initSession(planId);\n\n      // Create SSE connection for question streaming\n      if (sessionId) {\n        devLog('Creating SSE connection');\n        streamRef.current = clarificationApi.createQuestionStream(sessionId, event => {\n          devLog('Stream event received:', event.type);\n          handleStreamEvent(event);\n        }, errorMsg => {\n          devLog('Stream error:', errorMsg);\n          setError(errorMsg);\n        }, lang);\n      } else {\n        devLog('No session ID returned, cannot create stream');\n        setError(t('clarify.error.startFailed', lang));\n      }\n    } catch (err) {\n      devLog('Error starting session:', err);\n      setError(t('clarify.error.startFailed', lang));\n      toast.error(t('clarify.error.startFailed', lang));\n    } finally {\n      setLoading(false);\n    }\n  }, [planId, lang, initSession, resetSession, setLoading, setError, handleStreamEvent]);\n\n  // Submit an answer to the current question\n  const submitAnswer = useCallback(async value => {\n    if (!session || !session.questions.length) {\n      devLog('Cannot submit answer: no active session or questions');\n      return false;\n    }\n    try {\n      const currentQuestion = session.questions[session.currentQuestionIndex];\n      if (!currentQuestion) {\n        devLog('Cannot submit answer: no current question');\n        return false;\n      }\n      devLog('Submitting answer to question:', currentQuestion.id);\n      const answer = {\n        questionId: currentQuestion.id,\n        value,\n        timestamp: new Date()\n      };\n\n      // Add the answer to the local state\n      addAnswer(answer);\n\n      // Submit the answer to the backend\n      if (session.id) {\n        devLog('Sending answer to API');\n        await clarificationApi.submitAnswer(session.id, answer, lang);\n        devLog('Answer submitted successfully');\n      } else {\n        devLog('Session ID missing, answer only stored locally');\n      }\n      return true;\n    } catch (err) {\n      devLog('Error submitting answer:', err);\n      toast.error(t('api.errors.update', lang));\n      return false;\n    }\n  }, [session, addAnswer, lang]);\n\n  // Finish the session and generate the plan\n  const finishSession = useCallback(async () => {\n    if (!session || session.status !== 'in_progress') {\n      devLog('Cannot finish session: no active session or session not in progress');\n      return null;\n    }\n    try {\n      devLog('Finishing session');\n      setLoading(true);\n\n      // Mark the session as complete locally\n      completeSession();\n\n      // Complete the session on the backend and generate the plan\n      if (session.id) {\n        devLog('Calling API to complete session');\n        const generatedPlanId = await clarificationApi.completeSession(session.id, lang);\n        devLog('Session completed, plan generated with ID:', generatedPlanId);\n        return generatedPlanId;\n      } else {\n        devLog('Session ID missing, cannot complete session on backend');\n      }\n      return null;\n    } catch (err) {\n      devLog('Error completing session:', err);\n      toast.error(t('api.errors.default', lang));\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [session, completeSession, setLoading, lang]);\n\n  // Cleanup effect\n  useEffect(() => {\n    return () => {\n      // Close the SSE connection when the component unmounts\n      if (streamRef.current) {\n        devLog('Cleaning up SSE connection on unmount');\n        streamRef.current.close();\n        streamRef.current = null;\n      }\n    };\n  }, []);\n  return {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    startSession,\n    submitAnswer,\n    finishSession,\n    resetSession\n  };\n};\n_s(useClarificationSession, \"lW86liPKj7sDnLbm4iRcsQJ2Dtc=\", false, function () {\n  return [useClarificationStore];\n});","map":{"version":3,"names":["useEffect","useRef","useCallback","useClarificationStore","clarificationApi","toast","t","devLog","message","args","process","env","NODE_ENV","console","log","useClarificationSession","planId","lang","_s","session","isLoading","error","isStreamingQuestion","currentStreamedText","initSession","resetSession","handleStreamEvent","setError","setLoading","addAnswer","completeSession","streamRef","startSession","sessionId","current","createQuestionStream","event","type","errorMsg","err","submitAnswer","value","questions","length","currentQuestion","currentQuestionIndex","id","answer","questionId","timestamp","Date","finishSession","status","generatedPlanId","close"],"sources":["/home/devbox/project/src/features/clarification/hooks/useClarificationSession.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\nimport { useClarificationStore } from '../store/clarificationStore';\nimport { clarificationApi } from '../utils/api';\nimport { Answer, StreamEvent } from '../types';\nimport { toast } from 'sonner';\nimport { t } from '../../../lib/i18n';\nimport { Language } from '../../../lib/i18n';\n\n// 开发环境的日志帮助函数\nconst devLog = (message: string, ...args: any[]) => {\n  if (process.env.NODE_ENV !== 'production') {\n    console.log(`[Clarification Session] ${message}`, ...args);\n  }\n};\n\nexport const useClarificationSession = (planId?: string, lang: Language = 'en') => {\n  const {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    initSession,\n    resetSession,\n    handleStreamEvent,\n    setError,\n    setLoading,\n    addAnswer,\n    completeSession,\n  } = useClarificationStore();\n  \n  const streamRef = useRef<{ close: () => void } | null>(null);\n  \n  // Start a new session\n  const startSession = useCallback(async () => {\n    devLog('Starting new session');\n    try {\n      setLoading(true);\n      resetSession();\n      \n      // Start a session via the API\n      devLog('Calling API to start session');\n      const sessionId = await clarificationApi.startSession(planId, lang);\n      devLog('Session started with ID:', sessionId);\n      \n      // Initialize local session state\n      initSession(planId);\n      \n      // Create SSE connection for question streaming\n      if (sessionId) {\n        devLog('Creating SSE connection');\n        streamRef.current = clarificationApi.createQuestionStream(\n          sessionId,\n          (event: StreamEvent) => {\n            devLog('Stream event received:', event.type);\n            handleStreamEvent(event);\n          },\n          (errorMsg: string) => {\n            devLog('Stream error:', errorMsg);\n            setError(errorMsg);\n          },\n          lang\n        );\n      } else {\n        devLog('No session ID returned, cannot create stream');\n        setError(t('clarify.error.startFailed', lang));\n      }\n    } catch (err) {\n      devLog('Error starting session:', err);\n      setError(t('clarify.error.startFailed', lang));\n      toast.error(t('clarify.error.startFailed', lang));\n    } finally {\n      setLoading(false);\n    }\n  }, [planId, lang, initSession, resetSession, setLoading, setError, handleStreamEvent]);\n  \n  // Submit an answer to the current question\n  const submitAnswer = useCallback(async (value: string | number) => {\n    if (!session || !session.questions.length) {\n      devLog('Cannot submit answer: no active session or questions');\n      return false;\n    }\n    \n    try {\n      const currentQuestion = session.questions[session.currentQuestionIndex];\n      \n      if (!currentQuestion) {\n        devLog('Cannot submit answer: no current question');\n        return false;\n      }\n      \n      devLog('Submitting answer to question:', currentQuestion.id);\n      \n      const answer: Answer = {\n        questionId: currentQuestion.id,\n        value,\n        timestamp: new Date(),\n      };\n      \n      // Add the answer to the local state\n      addAnswer(answer);\n      \n      // Submit the answer to the backend\n      if (session.id) {\n        devLog('Sending answer to API');\n        await clarificationApi.submitAnswer(session.id, answer, lang);\n        devLog('Answer submitted successfully');\n      } else {\n        devLog('Session ID missing, answer only stored locally');\n      }\n      \n      return true;\n    } catch (err) {\n      devLog('Error submitting answer:', err);\n      toast.error(t('api.errors.update', lang));\n      return false;\n    }\n  }, [session, addAnswer, lang]);\n  \n  // Finish the session and generate the plan\n  const finishSession = useCallback(async () => {\n    if (!session || session.status !== 'in_progress') {\n      devLog('Cannot finish session: no active session or session not in progress');\n      return null;\n    }\n    \n    try {\n      devLog('Finishing session');\n      setLoading(true);\n      \n      // Mark the session as complete locally\n      completeSession();\n      \n      // Complete the session on the backend and generate the plan\n      if (session.id) {\n        devLog('Calling API to complete session');\n        const generatedPlanId = await clarificationApi.completeSession(session.id, lang);\n        devLog('Session completed, plan generated with ID:', generatedPlanId);\n        return generatedPlanId;\n      } else {\n        devLog('Session ID missing, cannot complete session on backend');\n      }\n      \n      return null;\n    } catch (err) {\n      devLog('Error completing session:', err);\n      toast.error(t('api.errors.default', lang));\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [session, completeSession, setLoading, lang]);\n  \n  // Cleanup effect\n  useEffect(() => {\n    return () => {\n      // Close the SSE connection when the component unmounts\n      if (streamRef.current) {\n        devLog('Cleaning up SSE connection on unmount');\n        streamRef.current.close();\n        streamRef.current = null;\n      }\n    };\n  }, []);\n  \n  return {\n    session,\n    isLoading,\n    error,\n    isStreamingQuestion,\n    currentStreamedText,\n    startSession,\n    submitAnswer,\n    finishSession,\n    resetSession,\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}