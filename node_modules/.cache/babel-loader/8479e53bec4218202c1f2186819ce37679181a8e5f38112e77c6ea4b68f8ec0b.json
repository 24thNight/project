{"ast":null,"code":"// 使用与StreamEvent中questionType相同的类型定义\n\n// 预设的中英文问题对\n\n// 更丰富的问题集合，添加SWOT分析问题类型\nconst mockQuestionPairs = [{\n  en: \"What are your strengths in English learning? For example, large vocabulary, good listening skills, etc.\",\n  zh: \"你在英语学习方面有哪些优势？例如词汇量大、听力好等\",\n  type: 'strength'\n}, {\n  en: \"What are the main difficulties you encounter in preparing for the IELTS exam?\",\n  zh: \"你在雅思考试备考中遇到的主要困难是什么？\",\n  type: 'weakness'\n}, {\n  en: \"What favorable factors in your environment can help you improve your English?\",\n  zh: \"你的环境中有哪些有利因素可以帮助你提高英语水平？\",\n  type: 'opportunity'\n}, {\n  en: \"What objective factors might hinder your preparation?\",\n  zh: \"有哪些可能会阻碍你备考的客观因素？\",\n  type: 'threat'\n}, {\n  en: \"What is your main motivation for achieving this goal?\",\n  zh: \"请描述一下你想实现这个目标的主要原因是什么？\",\n  type: 'open'\n}, {\n  en: \"In what timeframe would you like to complete this goal?\",\n  zh: \"你希望在什么时间范围内完成这个目标？\",\n  type: 'open'\n}, {\n  en: \"How will you measure success for this goal?\",\n  zh: \"你将如何衡量这个目标的成功？\",\n  type: 'open'\n}];\n\n// 根据语言选择问题列表\nconst getMockQuestions = (lang = 'en') => {\n  return mockQuestionPairs.map(q => ({\n    text: q[lang],\n    type: q.type || 'open'\n  }));\n};\n\n// 生成唯一ID\nconst generateId = () => `id-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n\n// 模拟延迟\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// 存储会话状态的缓存\nconst sessionCache = {};\nexport const mockClarificationApi = {\n  // 开始一个新的会话\n  startSession: async (planId, lang = 'en') => {\n    // 模拟网络延迟\n    await delay(800);\n    const sessionId = `session-${Date.now()}`;\n\n    // 初始化会话缓存\n    const questions = getMockQuestions(lang);\n    sessionCache[sessionId] = {\n      currentQuestionIndex: 0,\n      questions,\n      lang,\n      streamNextQuestion: async function () {},\n      // 将在createQuestionStream中设置\n      sendEndEvent: function () {},\n      // 将在createQuestionStream中设置\n      isClosed: false\n    };\n    return sessionId;\n  },\n  // 提交答案\n  submitAnswer: async (sessionId, answer, lang = 'en') => {\n    // 模拟网络延迟\n    await delay(500);\n\n    // 检查会话是否存在\n    if (!sessionCache[sessionId]) {\n      console.error('[Mock API] Session not found:', sessionId);\n      return false;\n    }\n    const session = sessionCache[sessionId];\n\n    // 如果还有下一个问题，流式发送它\n    if (session.currentQuestionIndex < session.questions.length - 1) {\n      // 增加问题索引\n      session.currentQuestionIndex += 1;\n\n      // 延迟一点时间后发送下一个问题\n      setTimeout(() => {\n        if (!session.isClosed) {\n          session.streamNextQuestion();\n        }\n      }, 800);\n    } else {\n      // 这是最后一个问题的答案，发送END事件\n      setTimeout(() => {\n        if (!session.isClosed) {\n          session.sendEndEvent();\n        }\n      }, 800);\n    }\n    return true;\n  },\n  // 完成会话并生成计划\n  completeSession: async sessionId => {\n    // 模拟网络延迟\n    await delay(1200);\n\n    // 清理会话缓存\n    if (sessionCache[sessionId]) {\n      sessionCache[sessionId].isClosed = true;\n      delete sessionCache[sessionId];\n    }\n    return `plan-${Date.now()}`;\n  },\n  // 创建模拟问题流\n  createQuestionStream: (sessionId, onEvent, onError, lang = 'en') => {\n    // 检查会话是否存在\n    if (!sessionCache[sessionId]) {\n      onError(`Session ${sessionId} not found`);\n      return {\n        close: () => {}\n      };\n    }\n    const session = sessionCache[sessionId];\n\n    // 设置发送END事件的函数\n    session.sendEndEvent = () => {\n      if (session.isClosed) return;\n      console.log('[Mock API] Sending END event');\n\n      // 发送END事件\n      onEvent({\n        type: 'end',\n        data: '[END]'\n      });\n    };\n\n    // 设置流式发送问题的函数\n    session.streamNextQuestion = async () => {\n      if (session.isClosed || session.currentQuestionIndex >= session.questions.length) return;\n      const index = session.currentQuestionIndex;\n      const question = session.questions[index];\n      const questionId = generateId();\n\n      // 模拟流式传输单词\n      const words = question.text.split(' ');\n\n      // 先发送空字符，触发UI显示\n      onEvent({\n        type: 'question',\n        data: ''\n      });\n\n      // 逐个单词发送，模拟流式效果\n      for (let i = 0; i < words.length; i++) {\n        if (session.isClosed) return;\n\n        // 中文使用较短的延迟，因为字符较少\n        await delay(session.lang === 'zh' ? 200 : 250);\n        onEvent({\n          type: 'question',\n          data: (i === 0 ? '' : ' ') + words[i]\n        });\n      }\n\n      // 发送问题完成事件\n      await delay(300);\n      if (!session.isClosed) {\n        onEvent({\n          type: 'completion',\n          data: 'question completed',\n          id: questionId,\n          questionType: question.type,\n          required: true\n        });\n      }\n    };\n\n    // 开始发送第一个问题\n    setTimeout(() => {\n      if (!session.isClosed) {\n        session.streamNextQuestion();\n      }\n    }, 1000);\n\n    // 返回关闭连接的方法\n    return {\n      close: () => {\n        if (sessionCache[sessionId]) {\n          sessionCache[sessionId].isClosed = true;\n        }\n        console.log('Mock SSE connection closed');\n      }\n    };\n  }\n};","map":{"version":3,"names":["mockQuestionPairs","en","zh","type","getMockQuestions","lang","map","q","text","generateId","Date","now","Math","floor","random","delay","ms","Promise","resolve","setTimeout","sessionCache","mockClarificationApi","startSession","planId","sessionId","questions","currentQuestionIndex","streamNextQuestion","sendEndEvent","isClosed","submitAnswer","answer","console","error","session","length","completeSession","createQuestionStream","onEvent","onError","close","log","data","index","question","questionId","words","split","i","id","questionType","required"],"sources":["/home/devbox/project/src/features/clarification/utils/mock-api.ts"],"sourcesContent":["import { Answer, StreamEvent } from '../types';\nimport { Language } from '../../../lib/i18n';\n\n// 使用与StreamEvent中questionType相同的类型定义\ntype QuestionType = 'open' | 'multiple_choice' | 'scale' | 'strength' | 'weakness' | 'opportunity' | 'threat';\n\n// 预设的中英文问题对\ninterface MockQuestion {\n  en: string;\n  zh: string;\n  type?: QuestionType;\n}\n\n// 更丰富的问题集合，添加SWOT分析问题类型\nconst mockQuestionPairs: MockQuestion[] = [\n  {\n    en: \"What are your strengths in English learning? For example, large vocabulary, good listening skills, etc.\",\n    zh: \"你在英语学习方面有哪些优势？例如词汇量大、听力好等\",\n    type: 'strength'\n  },\n  {\n    en: \"What are the main difficulties you encounter in preparing for the IELTS exam?\",\n    zh: \"你在雅思考试备考中遇到的主要困难是什么？\",\n    type: 'weakness'\n  },\n  {\n    en: \"What favorable factors in your environment can help you improve your English?\",\n    zh: \"你的环境中有哪些有利因素可以帮助你提高英语水平？\",\n    type: 'opportunity'\n  },\n  {\n    en: \"What objective factors might hinder your preparation?\",\n    zh: \"有哪些可能会阻碍你备考的客观因素？\",\n    type: 'threat'\n  },\n  {\n    en: \"What is your main motivation for achieving this goal?\",\n    zh: \"请描述一下你想实现这个目标的主要原因是什么？\",\n    type: 'open'\n  },\n  {\n    en: \"In what timeframe would you like to complete this goal?\",\n    zh: \"你希望在什么时间范围内完成这个目标？\",\n    type: 'open'\n  },\n  {\n    en: \"How will you measure success for this goal?\",\n    zh: \"你将如何衡量这个目标的成功？\",\n    type: 'open'\n  }\n];\n\n// 根据语言选择问题列表\nconst getMockQuestions = (lang: Language = 'en'): Array<{text: string, type: QuestionType}> => {\n  return mockQuestionPairs.map(q => ({\n    text: q[lang],\n    type: q.type || 'open'\n  }));\n};\n\n// 生成唯一ID\nconst generateId = () => `id-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n\n// 模拟延迟\nconst delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n// 存储会话状态的缓存\nconst sessionCache: Record<string, {\n  currentQuestionIndex: number,\n  questions: Array<{text: string, type: QuestionType}>,\n  lang: Language,\n  streamNextQuestion: () => Promise<void>,\n  sendEndEvent: () => void,\n  isClosed: boolean\n}> = {};\n\nexport const mockClarificationApi = {\n  // 开始一个新的会话\n  startSession: async (planId?: string, lang: Language = 'en') => {\n    // 模拟网络延迟\n    await delay(800);\n    const sessionId = `session-${Date.now()}`;\n    \n    // 初始化会话缓存\n    const questions = getMockQuestions(lang);\n    sessionCache[sessionId] = {\n      currentQuestionIndex: 0,\n      questions,\n      lang,\n      streamNextQuestion: async function() {},  // 将在createQuestionStream中设置\n      sendEndEvent: function() {},  // 将在createQuestionStream中设置\n      isClosed: false\n    };\n    \n    return sessionId;\n  },\n  \n  // 提交答案\n  submitAnswer: async (sessionId: string, answer: Answer, lang: Language = 'en') => {\n    // 模拟网络延迟\n    await delay(500);\n    \n    // 检查会话是否存在\n    if (!sessionCache[sessionId]) {\n      console.error('[Mock API] Session not found:', sessionId);\n      return false;\n    }\n    \n    const session = sessionCache[sessionId];\n    \n    // 如果还有下一个问题，流式发送它\n    if (session.currentQuestionIndex < session.questions.length - 1) {\n      // 增加问题索引\n      session.currentQuestionIndex += 1;\n      \n      // 延迟一点时间后发送下一个问题\n      setTimeout(() => {\n        if (!session.isClosed) {\n          session.streamNextQuestion();\n        }\n      }, 800);\n    } else {\n      // 这是最后一个问题的答案，发送END事件\n      setTimeout(() => {\n        if (!session.isClosed) {\n          session.sendEndEvent();\n        }\n      }, 800);\n    }\n    \n    return true;\n  },\n  \n  // 完成会话并生成计划\n  completeSession: async (sessionId: string) => {\n    // 模拟网络延迟\n    await delay(1200);\n    \n    // 清理会话缓存\n    if (sessionCache[sessionId]) {\n      sessionCache[sessionId].isClosed = true;\n      delete sessionCache[sessionId];\n    }\n    \n    return `plan-${Date.now()}`;\n  },\n  \n  // 创建模拟问题流\n  createQuestionStream: (\n    sessionId: string,\n    onEvent: (event: StreamEvent) => void,\n    onError: (error: string) => void,\n    lang: Language = 'en'\n  ) => {\n    // 检查会话是否存在\n    if (!sessionCache[sessionId]) {\n      onError(`Session ${sessionId} not found`);\n      return { close: () => {} };\n    }\n    \n    const session = sessionCache[sessionId];\n    \n    // 设置发送END事件的函数\n    session.sendEndEvent = () => {\n      if (session.isClosed) return;\n      \n      console.log('[Mock API] Sending END event');\n      \n      // 发送END事件\n      onEvent({\n        type: 'end',\n        data: '[END]'\n      });\n    };\n    \n    // 设置流式发送问题的函数\n    session.streamNextQuestion = async () => {\n      if (session.isClosed || session.currentQuestionIndex >= session.questions.length) return;\n      \n      const index = session.currentQuestionIndex;\n      const question = session.questions[index];\n      const questionId = generateId();\n      \n      // 模拟流式传输单词\n      const words = question.text.split(' ');\n      \n      // 先发送空字符，触发UI显示\n      onEvent({\n        type: 'question',\n        data: '',\n      });\n      \n      // 逐个单词发送，模拟流式效果\n      for (let i = 0; i < words.length; i++) {\n        if (session.isClosed) return;\n        \n        // 中文使用较短的延迟，因为字符较少\n        await delay(session.lang === 'zh' ? 200 : 250);\n        \n        onEvent({\n          type: 'question',\n          data: (i === 0 ? '' : ' ') + words[i],\n        });\n      }\n      \n      // 发送问题完成事件\n      await delay(300);\n      \n      if (!session.isClosed) {\n        onEvent({\n          type: 'completion',\n          data: 'question completed',\n          id: questionId,\n          questionType: question.type,\n          required: true\n        });\n      }\n    };\n    \n    // 开始发送第一个问题\n    setTimeout(() => {\n      if (!session.isClosed) {\n        session.streamNextQuestion();\n      }\n    }, 1000);\n    \n    // 返回关闭连接的方法\n    return {\n      close: () => {\n        if (sessionCache[sessionId]) {\n          sessionCache[sessionId].isClosed = true;\n        }\n        console.log('Mock SSE connection closed');\n      }\n    };\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}