{"ast":null,"code":"// 预设的问题列表，用于模拟API响应\nconst mockQuestions = [\"请描述一下你想实现这个目标的主要原因是什么？\", \"你希望在什么时间范围内完成这个目标？\", \"你认为实现这个目标的最大障碍是什么？\", \"你已经采取了哪些步骤来实现这个目标？\", \"你需要什么资源或技能来帮助你实现这个目标？\"];\n\n// 生成唯一ID\nconst generateId = () => `id-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n\n// 模拟延迟\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nexport const mockClarificationApi = {\n  // 开始一个新的会话\n  startSession: async planId => {\n    // 模拟网络延迟\n    await delay(800);\n    return `session-${Date.now()}`;\n  },\n  // 提交答案\n  submitAnswer: async (sessionId, answer) => {\n    // 模拟网络延迟\n    await delay(500);\n    return true;\n  },\n  // 完成会话并生成计划\n  completeSession: async sessionId => {\n    // 模拟网络延迟\n    await delay(1200);\n    return `plan-${Date.now()}`;\n  },\n  // 创建模拟问题流\n  createQuestionStream: (sessionId, onEvent, onError) => {\n    let questionIndex = 0;\n    let isClosed = false;\n\n    // 模拟流式发送问题的函数\n    const streamQuestion = async index => {\n      if (isClosed || index >= mockQuestions.length) return;\n      const question = mockQuestions[index];\n      const questionId = generateId();\n\n      // 模拟流式传输单词\n      const words = question.split(' ');\n\n      // 先发送空字符，触发UI显示\n      onEvent({\n        type: 'question',\n        data: ''\n      });\n\n      // 逐个单词发送，模拟流式效果\n      for (let i = 0; i < words.length; i++) {\n        if (isClosed) return;\n        await delay(250);\n        onEvent({\n          type: 'question',\n          data: (i === 0 ? '' : ' ') + words[i]\n        });\n      }\n\n      // 发送问题完成事件\n      await delay(300);\n      if (!isClosed) {\n        onEvent({\n          type: 'completion',\n          data: 'question completed',\n          id: questionId,\n          questionType: 'open',\n          required: true\n        });\n      }\n\n      // 在收到回答后发送下一个问题\n      // 实际会在submitAnswer调用后发送下一个问题，但这里我们模拟等待用户输入的时间间隔\n      if (index < mockQuestions.length - 1) {\n        await delay(1000); // 等待时间，模拟服务器处理\n        streamQuestion(index + 1);\n      }\n    };\n\n    // 开始发送第一个问题\n    setTimeout(() => {\n      streamQuestion(questionIndex);\n    }, 1000);\n\n    // 返回关闭连接的方法\n    return {\n      close: () => {\n        isClosed = true;\n        console.log('Mock SSE connection closed');\n      }\n    };\n  }\n};","map":{"version":3,"names":["mockQuestions","generateId","Date","now","Math","floor","random","delay","ms","Promise","resolve","setTimeout","mockClarificationApi","startSession","planId","submitAnswer","sessionId","answer","completeSession","createQuestionStream","onEvent","onError","questionIndex","isClosed","streamQuestion","index","length","question","questionId","words","split","type","data","i","id","questionType","required","close","console","log"],"sources":["/home/devbox/project/src/features/clarification/utils/mock-api.ts"],"sourcesContent":["import { Answer, StreamEvent } from '../types';\n\n// 预设的问题列表，用于模拟API响应\nconst mockQuestions = [\n  \"请描述一下你想实现这个目标的主要原因是什么？\",\n  \"你希望在什么时间范围内完成这个目标？\",\n  \"你认为实现这个目标的最大障碍是什么？\",\n  \"你已经采取了哪些步骤来实现这个目标？\",\n  \"你需要什么资源或技能来帮助你实现这个目标？\"\n];\n\n// 生成唯一ID\nconst generateId = () => `id-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n\n// 模拟延迟\nconst delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nexport const mockClarificationApi = {\n  // 开始一个新的会话\n  startSession: async (planId?: string) => {\n    // 模拟网络延迟\n    await delay(800);\n    return `session-${Date.now()}`;\n  },\n  \n  // 提交答案\n  submitAnswer: async (sessionId: string, answer: Answer) => {\n    // 模拟网络延迟\n    await delay(500);\n    return true;\n  },\n  \n  // 完成会话并生成计划\n  completeSession: async (sessionId: string) => {\n    // 模拟网络延迟\n    await delay(1200);\n    return `plan-${Date.now()}`;\n  },\n  \n  // 创建模拟问题流\n  createQuestionStream: (\n    sessionId: string,\n    onEvent: (event: StreamEvent) => void,\n    onError: (error: string) => void\n  ) => {\n    let questionIndex = 0;\n    let isClosed = false;\n    \n    // 模拟流式发送问题的函数\n    const streamQuestion = async (index: number) => {\n      if (isClosed || index >= mockQuestions.length) return;\n      \n      const question = mockQuestions[index];\n      const questionId = generateId();\n      \n      // 模拟流式传输单词\n      const words = question.split(' ');\n      \n      // 先发送空字符，触发UI显示\n      onEvent({\n        type: 'question',\n        data: '',\n      });\n      \n      // 逐个单词发送，模拟流式效果\n      for (let i = 0; i < words.length; i++) {\n        if (isClosed) return;\n        \n        await delay(250);\n        \n        onEvent({\n          type: 'question',\n          data: (i === 0 ? '' : ' ') + words[i],\n        });\n      }\n      \n      // 发送问题完成事件\n      await delay(300);\n      \n      if (!isClosed) {\n        onEvent({\n          type: 'completion',\n          data: 'question completed',\n          id: questionId,\n          questionType: 'open',\n          required: true\n        });\n      }\n      \n      // 在收到回答后发送下一个问题\n      // 实际会在submitAnswer调用后发送下一个问题，但这里我们模拟等待用户输入的时间间隔\n      if (index < mockQuestions.length - 1) {\n        await delay(1000); // 等待时间，模拟服务器处理\n        streamQuestion(index + 1);\n      }\n    };\n    \n    // 开始发送第一个问题\n    setTimeout(() => {\n      streamQuestion(questionIndex);\n    }, 1000);\n    \n    // 返回关闭连接的方法\n    return {\n      close: () => {\n        isClosed = true;\n        console.log('Mock SSE connection closed');\n      }\n    };\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}